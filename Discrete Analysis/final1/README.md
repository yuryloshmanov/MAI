# Дискретный анализ

## Оценка времени работы сортировок, использующих сравнение элементов
В наихудшем случае выполнение любого алгоритма сортировки сравнением выполняется за `\Omega(nlogn)`.

## Сортировка подсчётом

```cpp
template <class T>
void CountingSort(std::vector<T>& v, const int64_t upperBound) {
    if (v.size() < 2) {
        return;
    }
    
    std::vector<T> res(v.size());
    std::vector<int64_t> table(upperBound + 1);
    
    for (int64_t i = 0; i < v.size(); i++) {
        ++table[v[i]];
    }
    
    for (int64_t i = 1; i < table.size(); i++) {
        table[i] = table[i] + table[i - 1];
    }
    
    for (int64_t i = v.size() - 1; i >= 0; i--) {
        int64_t j = table[v[i]] - 1;
        --table[v[i]];
        res[j] = v[i];
    }
    
    v = res;
}
```


## Поразрядная сортировка
Сортировка подсчётом имеет существенный недостаток - выделение массива на `0..<upperBound` элементов.


## Карманная сортировка
Работает за `\Thetta(n^2)` в худшем случае, когда элементы не равномерно распределяются по карманам.


## Бинарные деревья поиска
### Свойства
Все операции выполняются за 

### Поиск
В

### Вставка
в

### Удаление
авы

### Повороты
фва

### Поиск следующего/предыдущего
фва


---- 
## Красно-черные деревья

### Свойства
1. Узлы могут быть либо `красными`, либо `чёрными`
2. Корень всегда чёрный
3. У красного элемента могут быть только чёрные потомки
4. Каждый `nullptr` элемент - чёрный
5. Чёрная высота везде одинаковая(число чёрных узлов по пути из корня в лист)

Все операции выполняются за `O(log(n))`

### Поиск
- Аналогично *BST*.


### Вставка
1. Вставить элемент, как в `BST`:
	- Если дерево пусто, вставить в корень и покрасить в чёрный (exit case)
	- Иначе вставить как красный узел
2. Проверить валидность свойств кчд:
	- Если отец узла *чёрный* -\> (exit case)
	- Если отец *красный*:
		- Если дядя *чёрный* -\> (exit case):
			1. Сделать балансировочный поворот
			2. Перекрасить отца и деда
		- Если дядя *красный*:
			1. Покрасить отца и дядю в чёрный
			2. Если дед не корень, то перекрасить его


###  Удаление
- Если узел **красный** - удаляем как в `BST`:
	- Если потомков нету, просто удаляем (exit case)
	- Если один потомок, заменяем своё значение на значение потомка, сохраняя красный цвет и вызываем удаление для потомка
	- Если потомка два, то ищем `inorder successor` или `inorder predicessor`, и делаем то же самое, что и пунктом выше

- Если узел **чёрный**:
	1. Удалить узел
		- Если узел - `лист`, то установить его значение в `nullptr` и сделать его `сверхчёрным(extra black, double black)`
		- Если существует `один` потомок и он `красный`:
			1. Скопировать значение красного узла в текущий
			2. Удалить красный узел
		- Иначе выполнить `BST` удаление
	2. Избавиться от `сверхчерноты`, если необходимо
		- Если корень сверхчёрный, то просто убрать сверхчерноту (exit case)
		- Если брат узла `чёрный` с чёрными потомками:
			1. Убрать сверхчерноту
			2. Передать черноту родителю:
				- Если родитель красный, то сделать его чёрным (exit case)
				- Иначе сделать его сверхчёрным
			3. Покрасить брата в красный
		- Если брат узла `красный`:
			1. Покрасить в чёрный брата
			2. Покрасить в красный отца
			3. Сделать поворот в сторону сверхчёрного узла
		- Если брат узла `чёрный` и его потомок, который дальше от узла - чёрный, а который ближе к узлу - красный:
			1. Покрасить брата в красный
			2. Покрасить красного сына брата в чёрный
			3. Повернуть их в направлении от узла
		- Если брат узла `чёрный` и его потомок, который дальше от узла - красный (exit case):
			1. Свапнуть цвета отца и брата
			2. Повернуть их в сторону узла
			3. Покрасить узел, который теперь стоит на месте брата в чёрный
			4. Убрать сверхчерноту
---- 
##  B-деревья

B-дерево всегда полное.
`t` - степень B-дерева.
Если `n` - число элементов в узле, то `t - 1 <= n <= 2t - 1`.
*2-3-4 дерево* - такое дерево, у которого `t = 2`.

---- 
## Алгоритм Бойера-Мура. Правило плохого символа, правило хорошего суффикса.

Сравнение элементов идёт с конца.

###  Правило плохого символа(ППС)
Сдвиг в ПППС определяется как: `j - badCharacter[pattern[j]]`.
`j` - индекс от начала паттерна.

Выбор между ПППС и РППС не даёт разницы в ассимптотики БМ.

#### ПППС
Вычисляется самое правое вхождение символов.
```cpp
std::map<char, int> badCharacter(const std::string &pattern) {
	std::map<char, int> result;
	for (size_t i = 0; i < pattern.size(); i++) {
		result[pattern[i]] = i;
	}
	
	return result;
}
```

#### РППС
Хранит в себе все позиции символов.
Если все позиции дают отрицательный сдвиг, то можно сдвинуть паттерн за его текущее место несовпадения в тексте.
```cpp
std::map<char, std::vector<int>> badCharacter(const std::string &pattern) {
	std::map<char, std::vector<int>> result;
	for (size_t i = 0; i < pattern.size(); i++) {
		result[pattern[i]].push_back(i);
	}
	
	return result;
}
```

###  Правило хорошего суффикса(ПХС)


####  Слабое ПХС
Не проверяет символ перед суффиксом.

#### Сильное ПХС
Проверяет символ перед суффиксом.
При сдвиге, выбирается самый правый суффикс, символ перед которым не совпадает с символом перед текущим суффиксом, в котором произошло несовпадение.

##### Вычисление 
1. Перевернуть паттерн
2. Посчитать для него Z-функцию
3. Посчитать N-функцию
	```cpp
	std::vector<int> N(z.rbegin(), z.rend());
	```
	Для позиции `i` N-функция говорит, что существует такая подстрока `(i - n[i])...i`, которая совпадает с суффиксом паттерна.
5. Посчитать `L'`-функцию
	```cpp
	for (int32_t i = 0, j; i < n - 1; i++) {
		j = n - N[i];
		L[j] = i;
	}
	```
	Для позиции `i` `L'`-функция говорит, что в элементе с индексом `L'[i]` содержится конец подстроки `(L'[i] - (n - i))...L'[i])`, которая совпадает с суффиксом паттерна.
6. Посчитать `l'`-функцию
	```cpp
	for (int32_t i = n - 1, j; i >= 0; i--) {
		j = n - i;
		l[i] = (N[j - 1] == j) ? (j - 1) : (l[i + 1]);
	}
	```
	Для позиции `i` `l'`-функция говорит, суффикс длинной `L'[i]` совпадает с префиксом строки.

### Поиск
1. В случае, когда `L'[i] = 0`, паттерн сдвигается на `n - l'[i]` позиций
2. В случае вхождения, паттерн сдвигается на `n - l'[2]` позиций
3. Когда первое сравнение дало несовпадение, паттерн сдвигается на 1 позицию

---- 
## Алгоритм Апостолико-Джанкарло

Алгоритм полностью повторяет алгоритм Бойера-Мура.
Он решает проблему: если какой-то суффикс паттерна совпал с частью текста, мы находим этот суффикс по сильному ПХС. Он позволяет не делать этих сравнений.

Заводится массив `M`, совпадающий с размером текста.
Пусть `i` - индекс, `x` - символ паттерна по этому индексу, `k` - число в массиве по этому индексу. Суть `k` заключается в том, что если приложить к этой позиции конец вашего паттерна, то паттерн совпадёт с текстом на строку `\alpha`, `k <= |\alpha|`. Может быть больше, но `k` точно совпадут.

Для начала считается, что ни один элемент массива не определён.

### Поиск
`i` - и
1. Предподсчитанных знаний нету:
	- `M[i]` не определено
	- `M[i] = N[j] = 0`
	Начинаем сравнивать `T[i]` и `T[j]`.
	Если они совпадают и `j = 1`, то мы нашли вхождение с `i`-го символа.
	Если они совпадают, делаем `--i`, `--j` и переходим к следующему шагу алгоритма.
	Если они не совпадают, то 
2.  


---- 
## Ахо
 - начало


