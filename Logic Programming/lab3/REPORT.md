#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Лошманов Ю.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |     5         |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение
Методом поиска решаются задачи, которые затруднительно по времени решать методом перебора.

Графы удобно воплощаются в прологе в виде дерева решений.
Зачастую, человек может решить на этом языке свою повседневную задачу на поиск самого быстрого по времени/короткого по пути варианта. Естественно, "руками" это могло делаться намного дольше и сложнее.


## Задание
8. Вдоль доски расположены лунки, в каждой из которых лежит красный, белый или синий шар. Одним ходом можно менять местами два любых шара. Добиться того, чтобы сначала шли все красные шары, все синие - последними, а белые - посередине. Решить задачу за наименьшее число ход.

## Принцип решения
В каждом поиске путь возвращается в обратном порядке, поэтому используем предикат reverse() для получения хорошо-читаемого ответа.

Поиск в глубину:
Дерево решений выглядит как проход от корня до всех листьев, от очередного листа возвращаемся бектрекингом. В итоге первый путь не обязательно будет кратчайшим. 
```prolog
path1([T|P],T,[T|P]).
path1(X,T,H) :- prolong(X,Y), path1(Y,T,H).

path_dfs(X,T,H) :- path1([X],T,L), reverse1(L,H).
```


Поиск в ширину:
Находим все пути (`findall`), из-за чего время выполнения данного поиска существенно увеличивается. Но в результате находится кратчайший путь, чем этот способ и удобен.
```prolog
path2([[T|P]|_],T,[T|P]).
path2([X|P],T,G) :- findall(P1,prolong(X,P1),L), append1(P,L,Y), !, path2(Y,T,G).
path2([_|P],T,G) :- path2(P,T,G).

path_bfs(X,T,G):- path2([[X]],T,L), reverse1(L,G).
```


Поиск в глубину с итеративным погружением:
Когда мы дошли до конечной вершины, параметр глубины (`DepthLimit`) равен `0` для отсечения тех путей, которые не точно соответствуют нашей глубине. Соответственно при этом первым ответом мы получим кратчайший путь. Сам алгоритм похож на поиск в глубину.
```prolog
path3([T|P],T,[T|P],0).
path3(X,T,H,N) :- N > 0, prolong(X,Y), N1 is N-1, path3(Y,T,H,N1).

search_id(S,F,P,DL) :- path3([S],F,P,DL).
search_id(S,F,P) :- integer1(Level), search_id(S,F,P,Level).

path_id(S,F,P) :- search_id(S,F,K), reverse1(K,P).
```



## Результаты

Поиск в глубину:
```
?- path_dfs(["b", "r", "b", "w", "r", "r", "w", "w", "b"] ,["r", "r", "r", "w", "w", "w", "b", "b", "b"], X).
X = [["b", "r", "b", "w", "r", "r", "w", "w"|...], ["b", "r", "b", "r", "w", "r", "w"|...], ["b", "r", "b", "r", "r", "w"|...], ["r", "b", "b", "r", "r"|...], ["r", "b", "r", "b"|...], ["r", "r", "b"|...], ["r", "r"|...], ["r"|...], [...|...]|...] .

?-
```

Поиск в ширину:
```
?- path_bfs(["b", "r", "b", "w", "r", "r", "w", "w", "b"] ,["r", "r", "r", "w", "w", "w", "b", "b", "b"], X).
X = [["b", "r", "b", "w", "r", "r", "w", "w"|...], ["b", "r", "b", "r", "w", "r", "w"|...], ["b", "r", "b", "r", "r", "w"|...], ["r", "b", "b", "r", "r"|...], ["r", "b", "r", "b"|...], ["r", "r", "b"|...], ["r", "r"|...], ["r"|...], [...|...]|...] .

?-

```

Поиск в глубину с итеративным погружением:
```
?- path_id(["b", "r", "b", "w", "r", "r", "w", "w", "b"] ,["r", "r", "r", "w", "w", "w", "b", "b", "b"], X).
X = [["b", "r", "b", "w", "r", "r", "w", "w"|...], ["b", "r", "b", "r", "w", "r", "w"|...], ["b", "r", "b", "r", "r", "w"|...], ["r", "b", "b", "r", "r"|...], ["r", "b", "r", "b"|...], ["r", "r", "b"|...], ["r", "r"|...], ["r"|...], [...|...]|...] .

?- 
```


! Алгоритм поиска |  Длина найденного первым пути  |  Время работы  |
|-------------------------------------------------------------------|
| В глубину       | 9                               | 0.000               |
| В ширину        | 9                               | 10.792               |
| ID              | 9                               | 0.496               |

Измерения времени производились с помощью предиката `time`.

## Выводы
Лабораторная работа научила меня совершать различные виды поиска в графах.

Поиск в глубину самый быстрый, он удобен для проверки наличия решения.

Поиск в ширину нужен для нахождения кратчайшего пути. Такой поиск может занимать продолжительное время.

Поиск в глубину с итеративным погружением похож на поиск в глубину, за исключением того факта, что можно ограничить глубину прохождения. Это может быть полезно для нахождения решения на глубине не дальше заданной.
