# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Лошманов Ю.А.

## Результат проверки

| Преподаватель | Дата | Оценка |
|-------------------|--------------|---------------|
| Сошников Д.В. | | |
| Левинская М.А.| |4|

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение
В результате выполнения курсового проекта я собираюсь лучше понять язык программирования Prolog, глубже понять логическое программирование. Эти знания помогут расширить мой кругозор, как программиста.

## Задание
1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: предикаты `parent(родитель, ребенок)`, `sex(человек, m/f)` 
3. Реализовать предикат проверки/поиска `шурина`
4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева
Я зарегистрировался на сайте www.myheritage.com, создал своё родословное дерево и скачал его в формате GETCOM. В нём 15 индивидуумов.

## Конвертация родословного дерева
Используя язык программирования Python, я конвертировал родословное дерево из формата GETCOM в файл Prolog. Программа сначала собирает данные о каждом персоне, записываю их в свойства экземпляра класса Person, а потом о каждой семье(жена, муж, дети). Дальше, используя эти данные, идёт запись в файл Пролога предикатов `parent(родитель, ребенок)` и `sex(человек, m/f)`.

Рассмотрим основную функцию, которая читает файл формата GETCOM. Она сначала парсит каждого человека, а потом каждую семью. Это нужно делать, так как некоторая информация об отношениях родства содержится в разделе файла о семьях. Функция вызывает методы `parse` у классов `Person` и `Family` и ориентируется по ключевым словам формата GETCOM. Например `INDI` значит, что идёт описание человека, а `FAM` - описание семьи.

```python
def parse_file(input_file):
    """
    Парсит файл на два списка: персоны и семья.
    """

    persons = []
    families = []
    buff = []
    fam = False
    flag = False

    for line in input_file:
        row = line.split()
        if not fam:
            if row[0] == "0" and row[1][0] == "@" and row[2] == "INDI":
                flag = True
                buff.append(row)
            elif row[0] == "0" and row[1][0] == "@" and row[2] == "FAM":
                fam = True
                buff.append(row)
            elif flag:
                buff.append(row)
                if row[0] == "1" and row[1] == "_UID":
                    p = Person()
                    p.parse(buff)
                    persons.append(p)
                    buff = []
                    flag = False
        else:
            buff.append(row)
            if row[0] == "1" and row[1] == "_UID":
                fam = Family()
                fam.parse(buff)
                families.append(fam)
                buff = []
                fam = False

    return persons, families
```

После конвертации получился файл `heritage.pl` со следующим содержанием:
```prolog
parent('******', '******').
...

sex('******', m).
sex('******', f).
...
```

## Предикат поиска родственника
Предикат `shurin` ищет родного брата жены человека. Так как в нашем распоряжении имеются только предикаты `parent` и `sex`, то обязательным условием будет считаться наличие ребёнка у супругов, иначе не получится понять кто с кем состоит в браке.

Чтобы исключить дубликаты, возникающие в случае, когда у шурина указаны оба родителя, используется вспомогательный предикат `shurins_parent`, который выводит одного родителя шурина.

Предикат `shurin` выводит всех сыновей человека, возвращённого предикатом `shurins_parent`.

```prolog
shurins_parent(GrandParent, X) :-
    parent(X, Child), parent(Wife, Child), sex(Wife, f), parent(GrandParent, Wife), parent(GrandParent, Shurin), sex(Shurin, m), !.

shurin(Shurin, X) :-
    shurins_parent(P, X), parent(P, Shurin), sex(Shurin, m).
```

Проверим работу предиката на конкретных примерах:

```prolog
?- shurin(X, '******').
X = '******'.

?-
```


```prolog
?- shurin(X, '******').
X = '******' ;
X = '******'.

?-
```

```prolog
?- shurin(X, '******').
false.

?-
```

## Определение степени родства
Создадим несколько предикатов, таких как `father`, `mother`, `brother`, `sister`, `son`, `dauther`, `grand_father`, `grand_mother`. Так же включим предикат `shurin` из предыдущего задания.

Реализуем поиск в глубину:
```prolog
print_relation([]).
print_relation([H|T]) :- print_relation(T), write(H),  write(' - ').

step(Curr, Prev, Y, Rel) :- (relation(Rel, Curr, Y); relation(Rel, Y, Curr)), not(member(Y, Prev)).

dfs(X, X, _, _).
dfs(Curr, Last, T, [Rev|Tl]) :- step(Curr, T, Next, Rev), dfs(Next, Last, [Curr|T], Tl).

dfs_path(Way, First, Last) :- dfs(First, Last, [], RevWay), reverse(RevWay, Way), print_relation(Way).

```

Предикат степени родства будет выглядеть так:
```prolog
relative(R, X, Y) :- relation(R, X, Y).
relative(Way, First, Last) :- dfs_path(Way, First, Last), !.
```

Проверим работу предиката:
```prolog
?- relative(R, '******', '******').
R = grand_mother ;
mother - mother - 
R = [mother, mother].

?- relative(R, '******', '******').
son - dauther - 
R = [dauther, son].

?- relative(R, '******', '******').
father - father - mother - 
R = [mother, father, father].

?- 
```

## Естественно-языковый интерфейс

## Выводы
Моё изучение логического программирования в МАИ началось с данной курсовой. Создать родословное дерево и написать его парсер оказалось достаточно простой задачей, а вот начать писать программы на совершенно другой парадигме - нет.

Данная курсовая работа помогла мне воспользоваться логическим программированием на примере собственного родословного дерева, ведь это гораздо интереснее, чем решение обычных задач.

Реферат помог мне подойти к программированию со стороны учителя, он мне очень напомнил реферат по объектно-ориентированному программированию, который я писал на первом курсе.
